# ① run

直接编译并运行 **带main包、main函数** 的源代码文件或包文件夹，如果没有main函数则run不起来。

此源代码文件可以不是 `main.go`

run命令作用于文件夹时，会直接运行此文件夹所代表的包，此包必须有一个有main包的源代码文件，而且必须有main函数。

# ② build

用于编译任意位置下的包，结果是可执行程序。

设当前目录是 `D:\codes\go-workshop\`，有一个源文件 `hello.go`

- 如果包含main包，没有main函数，则报错
- 如果包含main包，有main函数
    - 使用命令 `go build`，编译器就把当前目录作为包名生成可执行程序 `go-workshop.exe`
    - 使用命令 `go build hello.go`，编译器会生成 `hello.exe`，与上一条是一样的

所以注意，build 命令可作用于文件夹（此时这个文件夹就被当作包，包名即文件夹名），也可作用于某个源代码文件。作用于文件夹可以是相对路径也可以是绝对路径。

如果是作用于某个源代码文件，则此源代码文件必须包含 main 包和 main 函数，因为 build 命令只能产生可执行程序，如果不包含 main 包，则什么都不生成。

# ③ install

用于安装 `$GOPATH/src` 下的包到本地。假设 `$GOPATH/src` 下有一个文件夹叫 g3dtiles：

- 如果此文件夹内某源文件含 `main` 包、`main` 函数，那么会生成可执行程序 `g3dtiles.exe` 到 `$GOPATH/bin` 下。
- 如果此文件夹内某源文件含 `main` 包，无 `main` 函数，则报错。
- 如果不包含 `main` 包，那么就生成 `g3dtiles.a` 到 `$GOPATH/pkg/<操作系统与处理器位数>/` 下，作为一个库。此时，包内的代码文件可包含任意结构、任意包。

这里是把文件夹当一个包了。

install 命令只能作用于包（也即文件夹），对源代码文件是无效的。

## 如果只检索 GOROOT 而不检索 GOPATH

那是因为go变量 GO111MODULE 设为on了，要将其关闭

``` SHELL
go env -w GO111MODULE=off
```

# ④ 比较

| 命令    | 作用对象                                   | 生成结果        | 生成文件名                                                   |
| ------- | ------------------------------------------ | --------------- | ------------------------------------------------------------ |
| run     | 包或源代码文件（都必须有main包和main函数） | 无，直接运行exe | 不生成文件                                                   |
| build   | 包或源代码文件（都必须有main包和main函数） | exe             | 取决于是build文件还是包，包则是文件夹名称                    |
| install | `$GOPATH\src` 下的包                       | 库或exe         | 等于包名（文件夹名）。若是库，生成到  `$GOPATH\pkg\<系统与处理器位数>\`下 |

看得出来，build命令适合编译源代码成可执行程序然后发布软件，与 `GOPATH` 环境变量没什么关系。

run 命令则适合小文件测试

# ⑤ 最佳搭配

假设有一个文件夹 `g3dtiles`，打算编写一个可执行程序。

```
g3dtiles\
	def\
	loader\
	main.go
```

def 包、loader包 是 g3dtiles 的子包。

main.go是源代码文件，是g3dtiles 包的入口文件，包含 main 包和 main 函数。