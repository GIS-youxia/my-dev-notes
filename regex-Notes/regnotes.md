# 0~1~n 

## `?` : 0或1个

```
/used?/
```

这代表，d字母可有可无，下面两个都会匹配到：

```
use
used
```



## `*` : 0~n个

``` 
/ab*c/
```

代表 b 字母可以插在 a、c 字母中 0 ~ n 个。

```
ac
abc
abbbbbbbbbbbbbc
```



## `+`：1~n个，至少一个

```
/ab+c/
```

代表 a、c 字母之间，至少有 1 个 b。

```
abc
abbbbbbbbbbbc
```



## `{至少多少,至多多少}`：n~m个，范围

### 刚好n个

```
/ab{5}c/
```

代表字母 a、c 之间必须有 5 个字母 b。

```
abbbbbc
```

### n~m个

```
/ab{2,6}c/
```

代表字母 a、c 之间，若字母 b 有 2~6 个，则匹配。

```
abbc
abbbbc
abbbbbc
```

> 进阶：m可以不写，即匹配n个以上，{n, }
>
> 进阶2：n可以不写，即匹配m个以下，{, m}

# 组合：()

用括号表示一个组合

```
/(ab)+/
```

表示的是 `ab` 这个组合出现至少 1 次。

# 或：|

```
/a f|m/
```

这样，下面都能匹配到：

```
a f
a m
```

但是或的匹配对象是组合的话，要加括号

```
/a (cat|dog)/
```

下面前两个都能匹配到

```
a cat <-
a dog  <-
a bird
```

> 易犯错误写法：不写小括号
>
> /a cat|dog/，匹配到的是 `a cat` 和 `dog`

# 集合：[]（范围）

方括号，表示只能从里面列出的范围匹配

例如

```
/[abc]+/
```

这样只能匹配 `a`、`b`、`c` 三个字母的 1~n 个，下面3个会匹配到：

```
abc
abbc
aabbcc
```

> 不加 `+` 有什么区别？
>
> 不加 `+` 的话，对于 `asadijhioabc`，则会匹配到5次，即 `a`、`a`、`a`、`b`、`c`
>
> 而加了的话，则会匹配到三处，即 `a`、`a`、`abc`

## 省略写法 `a-c`

```
/[a-c]/
```

等同于 `/[abc]/`

## 省略写法 `a-cf-h`：分段

等同于 `/[abcfgh]/`

## 省略写法 `a-zA-Z0-9`：并排

等同于所有英文字母（大小写）和数字。

```
/[a-zA-Z0-9]+/
```

对于这种情况，下列所有字符串都会匹配到：

```
abc
tiger
aabbcc
dog
123456
abc123
ADogNameLucy
666fine
```

# 反选：`^`

`^` 表示的是除了 **方括号** 规则内的字符，其他的都匹配

```
/[^0-9]+/
```

这匹配的就是除了 0~9 数字外，其他所有的字符，包括换行。

> 它一般用于表示开头匹配

# 准备好了：元字符 `\d` `\w` `\s` `\D` `\W` `\S`

- `\d`：数字
- `\w`：英文字母、数字、下划线，等价 [a-zA-Z0-9] 和 下划线
- `\s`：space的意思，包括 tab符 和 换行符
- `\D`：非数字
- `\W`：非 `\w`
- `\S`：非 `\s`

# 任意字符 `.`

代表任意字符，不包括换行

```
/.*/
```

这样匹配到下列三行

```
This is a cat.
This is a dog.
This is a bird.
```

# 行首行尾：`^`、`$`

只匹配最开始的 a：

```
/^a/
```

这样会匹配到的是：

```
absorb
```

只匹配最后的 a：

```
/a$/
```

这样只匹配到：

```
tea
```

# 例子：匹配十六进制rgb六位颜色

```
/#[a-fA-F0-9]{6}\b/
```

# 例子：匹配 ip 地址

这个要转义 `.` 符号，即要匹配 ip 地址之间的 `.`，则要加反斜杠转义。

```
/\d+\.\d+\.\d+\.\d+/
```

但是，`\d+` 表示的是任意数字，这样数字 12938 也能匹配，但是 IP 地址只能是三位数，且最大 255，这样改：

```
/25[0-5]|2[0-4]\d|[01]?\d\d?/
```

表示匹配 0~255 的三位数，有3种情况，

- 25开头的只能是 250~255
- 2开头的只能是 20x ~ 24x（x代表数字）
- 0或1开头的只能是 1xx（x代表数字）、0xx，但是 0、1 也可以不存在来表示两位数，最后一个 \d 也可以不存在，用中间的 \d 表示一位数。

不妨设上面匹配 0 ~ 255 数字的规则设为 G，那么匹配 IPv4 地址可以写为

```
/\b(G\.){3}G\b/
```

# 补充：懒惰匹配

对于下列情况：

```
<p><span>hello</span></p>
```

我只想匹配 `<p>` `<span>`、`</span>` 和 `</p>`

```
/<.+?>/
```

这样加个 ? ，匹配的结果是 `<p>` `<span>`、`</span>` 和 `</p>`

若不加，直接全部匹配：`<p><span>hello</span></p>`

>个人理解就是，以 `<` 开始，若没匹配到最后的 `>` 则继续按中间 `.+` 规则匹配，第一次遇到 `>` 就结束。
>
>若不是懒惰匹配，则第一次遇到 `>` 并不会结束

# 补充：`\b`

表示边界



# 完全参考

https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md