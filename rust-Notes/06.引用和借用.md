# 引用与借用

引用仅传递 **访问权**，不传递 **所有权**，也就是说

一个引用变量的值，在离开作用域后，并不会被销毁。相当于 C++ 传对象指针，C#传普通对象的变量。

``` RUST
fn main() {
  let s1 = String::from("hello");
  let len = get_string_length(&s1); // 传引用，并不失去s1对内容的指向
  
  println!("The length of '{}' is {}.", s1, len);
}

fn get_string_length(s: &String) -> usize {
  // 在此处，s叫做借用变量，是不可改变的，除非加上 mut 关键字，见下例
  s.len()
} // 离开作用域，销毁s，但是不销毁s指向的内容
```

使用借用变量修改其指向的值

``` RUST
fn main() {
  let mut s1 = String::from("hello");
  let len = get_string_length(&mut s1); // 传引用 (可变引用)
  
  println!("The length of '{}' is {}.", s1, len);
}

fn get_string_length(s: &mut String) -> usize {
  s.push_str(", world!");
  s.len();
}
```

若想使用借用变量去修改堆内存上的值，必须在创建时、传引用时、参数列表上都标为 mut

## 同作用域 可变引用 只能有一个，且不能与 不可变引用 混用

防止数据访问冲突。

``` RUST
fn main() {
  let mut s1 = ...;
  let s2 = &mut s1;
  let s3 = &mut s1; // 不允许
  {
    let s4 = &mut s1; // 允许
  }
}
```

## 不可变引用可以有多个

略，因为不可更改。



# 悬空引用：野指针

即传出来一个引用，但是传出来后引用的指向就销毁了，尽管传出来的是引用，但是已经不引用任何东西了

``` RUST
fn main() {
  let t = get_string();
}

fn get_string() -> &String {
  let s = String::from("hello");
  &s // 传出引用
} // s的引用（堆内存）销毁，s传出去了个寂寞
```

